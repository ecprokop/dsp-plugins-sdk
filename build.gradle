apply plugin: 'java'

apply from: "$rootDir/integration.gradle"
applyIntegrationTests()

repositories {
  maven {
    name "Splunk Mirror - All"
    url "https://repo.splunk.com/artifactory/maven/"
  }
}

buildscript {
  repositories {
    maven {
      name "Splunk Mirror - All"
      url "https://repo.splunk.com/artifactory/maven/"
    }
  }

  dependencies {
    classpath 'com.github.jengelman.gradle.plugins:shadow:2.0.4'
  }
}
apply plugin: 'com.github.johnrengelman.shadow'

def depLibs = [
  'com.google.guava:guava:15.0',
  'org.slf4j:slf4j-api:1.7.5',
  'org.slf4j:slf4j-log4j12:1.7.5',
  'org.apache.flink:flink-streaming-java_2.11:1.3.2',
  'com.splunk:splunk-streaming-flink-planner:2.4.0-SNAPSHOT'
]

dependencies {
  // Basic plugin dependencies provided by data-pipelines. Each dependency is scoped to the
  // compileOnly and testCompile contexts to keep them out of the shadow/uber jar
  depLibs.each { dep ->
    compileOnly dep
    testCompile dep
  }

  testCompile group: 'com.splunk', name: 'splunk-streaming-flink-test', version: '2.4.0-SNAPSHOT'
  testCompile group: 'junit', name: 'junit', version: '4.12'
  testCompile group: 'org.mockito', name: 'mockito-core', version: '1.9.5'

  // Add custom dependencies here
  // compile group: 'com.foo', name: 'bar', version: '1.0.0'
}

tasks.withType(JavaCompile) { JavaCompile task ->
  task.sourceCompatibility = project.property("javaCompiler.sourceCompatibility")
  task.targetCompatibility = project.property("javaCompiler.targetCompatibility")
}

task createPluginJar(dependsOn: shadowJar) {
  group 'build'
  description 'Create a plugin jar packaged with dependencies'
}

// Run this task to create initial project template.
task expandTemplates(type: Copy) {
  group 'templates'
  description 'Perform initial template expansion. Will overwrite any existing source.'

  from ("${project.rootDir}/templates/${project.properties.get('SDK_FUNCTION_TYPE')}") {
    expand(project.properties)
  }
  into "${project.rootDir}/src"
  outputs.upToDateWhen { false }

  doLast {
    // Rename streaming implementation templates
    def mainDirBase = "${project.rootDir}/src/main/java/com/splunk/streaming/user/"
    renameJavaFile(mainDirBase+"functions/", "Function.java", "${project.properties.SDK_CLASS_NAME}Function.java")

    // Rename streaming test templates
    if (project.properties.get('SDK_FUNCTION_TYPE') == 'scalar') {
      def testDirBase = "${project.rootDir}/src/test/java/com/splunk/streaming/user/"
      renameJavaFile(testDirBase, "TestFunction.java", "Test${project.properties.SDK_CLASS_NAME}Function.java")
    } else {
      def testDirBase = "${project.rootDir}/src/test-it/java/com/splunk/streaming/user/"
      renameJavaFile(testDirBase, "TestFunctionIT.java", "Test${project.properties.SDK_CLASS_NAME}FunctionIT.java")
    }

    // Add plugin to META-INF/services file
    def resourcesBase = "${project.rootDir}/src/main/resources/META-INF/services/"
    new File(resourcesBase).mkdirs()

    String className = "";
    switch (project.properties.get('SDK_FUNCTION_TYPE')) {
      case "scalar":
        className = "com.splunk.streaming.upl3.core.ScalarFunction"
        break
      case "streaming":
        className = "com.splunk.streaming.flink.streams.core.StreamingFunction"
        break
      case "sink":
        className = "com.splunk.streaming.flink.streams.core.SinkFunction"
        break
      default:
        throw new InvalidUserDataException("Unknown SDK function type: ${project.properties.get('SDK_FUNCTION_TYPE')}")
        break
    }
    addLine(resourcesBase + className, "com.splunk.streaming.user.functions.${SDK_CLASS_NAME}Function")
  }
}

ext.renameJavaFile = { String dir, String templateName, String newFilename ->
  if (!dir.endsWith('/')) {
    throw new InvalidUserDataException("directory should end in slash: " + dir)
  }
  file(dir+templateName).renameTo(file(dir+newFilename))
}

ext.addLine = { String filename, String newLine ->
  def lineFound = false
  def file = new File(filename)
  file.createNewFile() // create file if doesn't exist

  file.readLines().each { line ->
    if (line.trim() == newLine) {
      lineFound = true
    }
  }
  if (!lineFound) {
    file.append(newLine+"\n")
  }
}
