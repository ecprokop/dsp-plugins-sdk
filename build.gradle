import groovyx.net.http.ApacheEncoders
import groovyx.net.http.FromServer
import static groovyx.net.http.HttpBuilder.configure
import static groovyx.net.http.MultipartContent.multipart

apply plugin: 'java'

apply from: "$rootDir/integration.gradle"
applyIntegrationTests()

repositories {
  maven {
    name "Splunk Mirror - All"
    url "https://repo.splunk.com/artifactory/maven/"
  }
}

buildscript {
  repositories {
    maven {
      name "Splunk Mirror - All"
      url "https://repo.splunk.com/artifactory/maven/"
    }
  }

  dependencies {
    classpath 'com.github.jengelman.gradle.plugins:shadow:2.0.4'
    classpath 'io.github.http-builder-ng:http-builder-ng-apache:1.0.3'
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.2'
  }
}
apply plugin: 'com.github.johnrengelman.shadow'

def depLibs = [
  'com.google.guava:guava:15.0',
  'org.slf4j:slf4j-api:1.7.5',
  'org.slf4j:slf4j-log4j12:1.7.5',
  'org.apache.flink:flink-streaming-java_2.11:1.3.2',
  'com.splunk:splunk-streaming-flink-planner:2.4.0-SNAPSHOT'
]

dependencies {
  // Basic plugin dependencies provided by data-pipelines. Each dependency is scoped to the
  // compileOnly and testCompile contexts to keep them out of the shadow/uber jar
  depLibs.each { dep ->
    compileOnly dep
    testCompile dep
  }

  testCompile group: 'com.splunk', name: 'splunk-streaming-flink-test', version: '2.4.0-SNAPSHOT'
  testCompile group: 'com.splunk', name: 'splunk-streaming-scalar-functions', version: '2.4.0-SNAPSHOT'
  testCompile group: 'junit', name: 'junit', version: '4.12'
  testCompile group: 'org.mockito', name: 'mockito-core', version: '1.9.5'

  // Add custom dependencies here
  // compile group: 'com.foo', name: 'bar', version: '1.0.0'
}

tasks.withType(JavaCompile) { JavaCompile task ->
  task.sourceCompatibility = project.property("javaCompiler.sourceCompatibility")
  task.targetCompatibility = project.property("javaCompiler.targetCompatibility")
}

task createPluginJar(dependsOn: shadowJar) {
  group 'build'
  description 'Create a plugin jar packaged with dependencies'
}

// Run this task to create initial project template.
task expandTemplates(type: Copy) {
  group 'templates'
  description 'Perform initial template expansion. Will overwrite any existing source.'

  // expands files from the given path to the src directory
  // now allows multiple functions in one plugin
  from ("${project.rootDir}/${project.properties.get('SDK_FUNCTIONS_PATH')}") {
    expand(project.properties)
  }
  into "${project.rootDir}/src"
  outputs.upToDateWhen { false }

  doLast {
    // removing the renaming until we can talk about some new design.
  }
}

task getPlugins() {
  doLast {
    def token = readToken()
    def http = configure {
      request.uri = getUploadServiceURI()
    }

    http.get {
      request.uri.path = getUploadServicePath()
      request.headers['Authorization'] = "Bearer ${token}"
      response.success { fromServer, body ->
        println body
      }
      response.failure { fromServer, body ->
        def msg = httpErrorMsg("Error fetching plugins", fromServer, body)
        throw new GradleException(msg)
      }
    }
  }
}

task registerPlugin() {
  doLast {
    def token = readToken()
    def http = configure {
      request.uri = getUploadServiceURI()
    }

    def name = project.properties.get('SDK_PLUGIN_NAME')
    def desc = project.properties.get('SDK_PLUGIN_DESC') ?: ''

    http.post {
      request.uri.path = getUploadServicePath()
      request.contentType = 'application/json'
      request.headers['Authorization'] = "Bearer ${token}"
      request.body = "{\"name\": \"${name}\", \"description\": \"${desc}\"}"
      response.success { fromServer, body ->
        println "Registered plugin: ${name}. Response: ${body}"
      }
      response.failure { fromServer, body ->
        def msg = httpErrorMsg("Error registering plugin ${name}", fromServer, body)
        throw new GradleException(msg)
      }
    }
  }
}

task uploadPlugin() {
  doLast {
    def pluginIdProperty = 'PLUGIN_ID'
    if (!project.hasProperty(pluginIdProperty)) {
      throw new InvalidUserDataException("Must specify plugin id via gradle property: ${pluginIdProperty}")
    }
    def id = project.properties.get(pluginIdProperty)
    File plugin = new File('build/libs/data-pipelines-plugin-template.jar')

    def token = readToken()
    def http = configure {
      request.uri = getUploadServiceURI()
    }

    http.post {
      request.uri.path = "${getUploadServicePath()}/${id}/upload"
      request.contentType = 'multipart/form-data'
      request.headers['Authorization'] = "Bearer ${token}"
      request.body = multipart {
        part 'pluginJar', 'data-pipelines-plugin-template.jar', 'application/octet-stream', plugin
      }
      request.encoder 'multipart/form-data', ApacheEncoders.&multipart
      response.success { fromServer, body ->
        println "Uploaded jar file for plugin id: ${id}"
      }
      response.failure { fromServer, body ->
        def msg = httpErrorMsg("Error uploading plugin ${name}", fromServer, body)
        throw new GradleException(msg)
      }
    }
  }
}

ext.renameJavaFile = { String dir, String templateName, String newFilename ->
  if (!dir.endsWith('/')) {
    throw new InvalidUserDataException("directory should end in slash: " + dir)
  }
  file(dir+templateName).renameTo(file(dir+newFilename))
}

ext.addLine = { String filename, String newLine ->
  def lineFound = false
  def file = new File(filename)
  file.createNewFile() // create file if doesn't exist

  file.readLines().each { line ->
    if (line.trim() == newLine) {
      lineFound = true
    }
  }
  if (!lineFound) {
    file.append(newLine+"\n")
  }
}

ext.readToken = {
  String tokenFileProperty = "SCLOUD_TOKEN_FILE"
  if (!project.hasProperty(tokenFileProperty)) {
    throw new InvalidUserDataException("Missing required gradle property: ${tokenFileProperty}")
  }
  String fileName = project.properties.get(tokenFileProperty)
  File tokenFile = new File(fileName)
  if (tokenFile.text.isEmpty()) {
    throw new InvalidUserDataException("Token file is empty. File: ${fileName}")
  }
  return tokenFile.text.trim()
}

ext.httpErrorMsg = { String msg, FromServer fs, Object body ->
  return "${msg}. Status code: ${fs.getStatusCode().toString()}. Response: ${body}"
}

ext.getUploadServiceURI = {
  def proto = project.properties.get('PLUGIN_UPLOAD_SERVICE_PROTOCOL')
  def host = project.properties.get('PLUGIN_UPLOAD_SERVICE_HOST')
  def port = project.properties.get('PLUGIN_UPLOAD_SERVICE_PORT')
  return "${proto}://${host}:${port}/"
}

ext.getUploadServicePath = {
  def tenant = project.properties.get('TENANT_NAME') ?: 'default'
  def endpoint = project.properties.get('PLUGIN_UPLOAD_SERVICE_ENDPOINT')
  return "/${tenant}/${endpoint}"
}
